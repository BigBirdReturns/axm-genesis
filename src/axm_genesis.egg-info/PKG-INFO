Metadata-Version: 2.4
Name: axm-genesis
Version: 1.0.2
Summary: Protocol for immutable, content-addressed knowledge graphs
License: Apache-2.0
Requires-Python: >=3.10
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: blake3>=0.4.0
Requires-Dist: pynacl>=1.5.0
Requires-Dist: pyarrow>=14.0.0
Requires-Dist: duckdb>=0.9.0
Requires-Dist: click>=8.0.0
Requires-Dist: python-docx>=1.1.0
Requires-Dist: pdfplumber>=0.11.0
Provides-Extra: dev
Requires-Dist: pytest>=7.0; extra == "dev"
Requires-Dist: ruff>=0.1.0; extra == "dev"
Dynamic: license-file

# AXM Genesis

**Knowledge you can own, verify, and keep.**

## The Problem

Right now, almost all "AI knowledge" has these properties:

- It only exists at inference time
- It is recomputed over and over
- You cannot inspect it
- You cannot move it
- You cannot verify where it came from
- You cannot keep it without paying rent

Even when the answer is correct, it evaporates.

## The Solution

AXM Genesis compiles documents into **signed, verifiable knowledge shards** that work offline, forever.

It splits AI into two phases:

**Phase 1: Expensive extraction (done once)**
- Large models read documents
- Extract entities and claims
- Bind every claim to byte-level source evidence
- Sign and Merkle-root the result
- Freeze it

**Phase 2: Cheap use (forever)**
- Small models, scripts, or humans query the frozen shard
- Offline, deterministically, without recomputation
- Without trusting the builder
- Without calling an API

Knowledge becomes **compiled**, not performed.

## What's in a Shard

A shard is a directory containing:

```
manifest.json          # Signed metadata + Merkle root
sig/                   # Ed25519 signature + public key
content/               # Source documents
graph/
  entities.parquet     # Things (procedures, conditions, tools)
  claims.parquet       # Facts (tourniquet treats severe_bleeding)
  provenance.parquet   # Which claim came from which bytes
evidence/
  spans.parquet        # The actual source text for each claim
```

Every claim traces back to exact bytes in the source document. No hallucination can survive verification.

## Quick Start

```bash
# Install
pip install -e .

# Verify the gold shard
axm-verify shard shards/gold/fm21-11-hemorrhage-v1/ --trusted-key keys/canonical_test_publisher.pub
# {"status": "PASS", "error_count": 0, "errors": []}

# Query it
python examples/query_shard.py shards/gold/fm21-11-hemorrhage-v1/
```

## The Gold Shard

The repository includes a gold shard extracted from FM 21-11, the US Army's field manual for first aid. It contains:

- 8 entities (procedures like "tourniquet", conditions like "severe bleeding")
- 6 claims with byte-level provenance
- Signed with a canonical test key
- Passes verification

This shard proves the system works in a domain where hallucination is unacceptable.

## Why This Matters

Cloud AI companies profit because:
- Every question triggers compute
- Every answer disappears
- You must ask again tomorrow

AXM Genesis inverts this:
- Pay once to compile knowledge
- Keep the output forever
- Copy it, verify it, run it offline
- Nobody can revoke it

This is the same shift Linux made: from time-sharing to personal computing, from vendor permission to user possession.

AXM does that for knowledge.

## Documentation

- [Specification](spec/v1.0/SPECIFICATION.md) - The frozen protocol definition
- [Conformance](spec/v1.0/CONFORMANCE.md) - Minimum requirements for valid shards
- [Contributing](CONTRIBUTING.md) - How to propose changes (RFC process)

## Project Status

This is a working protocol with:
- A reference verifier (`axm-verify`)
- A gold shard that passes verification
- Test vectors for reimplementation
- Governance documents for community development

It is ready for use and extension.

## License

Apache-2.0


## Reimplementation Notes

AXM Genesis can be reimplemented in any language using only the following primitives:

- Canonical UTF-8 text normalization (lowercase, trim, collapse whitespace)
- Deterministic JSON serialization (sorted keys, no whitespace)
- BLAKE3 for content and Merkle hashing
- Ed25519 for signatures
- Parquet files with explicit schemas and deterministic row ordering

Correctness is defined by the ability to verify the gold shard byte-for-byte.
Any verifier implementation that accepts the gold shard and rejects the invalid test vectors is conformant.
